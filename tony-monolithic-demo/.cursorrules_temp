# Tony Monolithic Demo - Kotlin单体应用开发规则

## 项目概述
Tony Monolithic Demo 是一个基于 Kotlin + Spring Boot 的单体应用脚手架，采用分层架构设计，集成企业级开发所需的各种功能，包括用户管理、权限控制、数据访问、缓存、任务调度等。

## 技术栈
- **编程语言**: Kotlin 2.2.0+
- **构建工具**: Gradle (Kotlin DSL)
- **核心框架**: Spring Boot 3.5.0+, Spring Framework 6.2.8+
- **数据库**: MySQL 9.3.0, Redis
- **ORM**: MyBatis Plus 3.5.12
- **缓存**: Redis + Spring Cache
- **任务调度**: PowerJob 5.1.1
- **API文档**: Knife4j 4.6.0
- **序列化**: Jackson 2.19.1
- **安全**: JWT, Spring Security
- **Web服务器**: Undertow

## 项目结构

### 模块划分
- **tony-api**: Web层，包含控制器和配置
- **tony-service**: 业务逻辑层，包含服务实现
- **tony-dto**: 数据传输对象层
- **tony-job**: 定时任务模块

### 分层架构
```
┌─────────────────────────────────────────┐
│              tony-api                   │
│  (Controller, Config, Interceptor)      │
├─────────────────────────────────────────┤
│             tony-service                │
│        (Business Logic)                 │
├─────────────────────────────────────────┤
│              tony-dto                   │
│        (Data Transfer Objects)          │
├─────────────────────────────────────────┤
│             Database Layer              │
│      (MySQL, Redis, MyBatis Plus)       │
└─────────────────────────────────────────┘
```

## 开发规范
 所有依赖及常用方法尽可能使用tony-bootstarters内的, 然后才是其他第三方库.
### 分层设计原则
- **表现层**: 处理HTTP请求，参数验证，响应封装
- **业务层**: 实现业务逻辑，事务管理
- **数据层**: 数据访问，缓存操作
- **DTO层**: 数据传输对象，接口契约

### 包结构规范
```
tony-api/
├── src/main/kotlin/tony/{项目名}/
│   ├── config/            # 配置类
│   ├── interceptor/       # 拦截器
│   ├── permission/        # 权限控制
│   ├── sys/               # 具体功能模块(系统管理)
│   ├── └── controller/    # 控制器
│   └── sale/              # 具体功能模块(销售管理)
│       └── controller/    # 控制器
├── src/main/resources/
│   ├── application.yml    # 应用配置
│   ├── logback-spring.xml # 日志配置
│   └── static/            # 静态资源
└── src/test/              # 测试代码

tony-service/
├── src/main/kotlin/tony/{项目名}/
│   ├── {模块}/service/         # 业务服务
│   ├── {模块}/dao/             # 数据访问
│   ├── {模块}/po/          # 实体类
│   └── utils/           # 工具类
└── src/test/            # 测试代码

tony-dto/
├── src/main/kotlin/tony/{项目名}/
│   ├── {模块}/dto/req/         # 请求对象
│   ├── {模块}/dto/resp/        # 响应对象
│   └── {模块}/dto/enum/        # 枚举
└── src/test/           # 测试代码
```

### 命名规范
- **控制器**: `{功能}Controller` (如: `UserController`)
- **服务**: `{功能}Service` (如: `UserService`)
- **数据访问**: `{功能}Dao` (如: `UserDao`)
- **实体**: `{功能}` (如: `User`)
- **DTO**: `{功能}Req/Resp` (如: `UserReq`, `UserResp`)

## 代码规范

### 控制器层规范
全部使用HTTP POST方法, 及个别方法使用 GET, 手动控制. url全都写在方法上, 而不是类上, 便于查找及编辑.
url格式: {模块}/{功能}/{方法}, 不刻板要求符合REST.
```kotlin
@RestController
class UserController(
    private val userService: UserService
) {
    @GetMapping("/sys/user/detail")
    fun getUser(@Validated @RequestBody req: UserDetailReq): UserResp {
        return userService.getUser(req)
    }

    @PostMapping("/sys/user/create")
    fun createUser(@Validated @RequestBody req: UserReq): UserResp {
        return userService.createUser(request)
    }
}
```

### 服务层规范
```kotlin
@Service
@Transactional
class UserService(
    private val userDao: UserDao
) {
    fun getUser(req: UserDetailReq): UserResp {
        val user = userDao.selectByIdNotNull(req.id)
        return UserResp.from(user)
    }

    fun createUser(req: UserReq): UserResp {
        val user = User.from(req)
        val savedUser = userDao.save(user)
        return UserResp.from(savedUser)
    }
}
```

### 数据访问层规范
```kotlin
public interface UserDao : BaseDao<User> {
}
```

### DTO规范
```kotlin
data class UserRequest(
    val username: String,
    val email: String,
    val password: String
) {
    fun toUser(): User = User(
        username = username,
        email = email,
        password = password.encrypt()
    )
}

data class UserResp(
    val id: Long,
    val username: String,
) {
    companion object {
        fun from(user: User) = UserResp(
            id = user.id,
            username = user.username,
            email = user.email
        )
    }
}
```

## 配置管理

### 应用配置
```yaml
server:
  port: 10000
spring:
  profiles:
    default: dev
  application:
    name: tony-api
  datasource:
    url: jdbc:mysql://localhost:3306/tony_api
    username: tony_api
    password: tony_api
    driver-class-name: com.mysql.cj.jdbc.Driver
  data:
    redis:
      password: "123456"
mybatis-plus:
  global-config:
    db-config:
      logic-not-delete-value: 'null'
      logic-delete-value: 'CURRENT_TIMESTAMP'
```

### 环境配置
- **开发环境**: `application-dev.yml`
- **生产环境**: `application-prod.yml`
- **测试环境**: `application-test.yml`

### 日志配置
- 使用 Logback 进行日志管理
- 按包和级别配置日志输出
- 支持日志文件轮转
- 结构化日志格式

## 数据库设计

### 表设计规范
- 使用下划线命名法
- 包含基础字段 ({表名}_id,  create_time, creator_id, creator_name, update_time, updator_id, updator_name, delete_time)
- 使用逻辑删除
- 合理设计索引

### 实体类规范
```kotlin
@TableName("sys_employee")
class Employee {
    /**
     * 员工id
     */
    @TableId
    var employeeId: String = ""

    /**
     * 员工登录名
     */
    @TableField(
        updateStrategy = FieldStrategy.NOT_EMPTY
    )
    var account: String = ""

    /**
     * 员工真实姓名
     */
    @TableField(
        updateStrategy = FieldStrategy.NOT_EMPTY
    )
    var realName: String = ""

    /**
     * 员工手机号
     */
    @TableField(
        updateStrategy = FieldStrategy.NOT_EMPTY
    )
    var employeeMobile: String = ""

    /**
     * 密码
     */
    @TableField(
        updateStrategy = FieldStrategy.NOT_EMPTY
    )
    var pwd: String = ""

    /**
     * 状态：1-启用，0-禁用
     */
    var enabled: Boolean? = null

    /**
     * 备注
     */
    @TableField(
        updateStrategy = FieldStrategy.NOT_EMPTY
    )
    var remark: String = ""

    /**
     * 创建时间
     */
    @OrderBy
    @TableField(
        insertStrategy = FieldStrategy.NEVER,
        updateStrategy = FieldStrategy.NEVER
    )
    var createTime: LocalDateTime = LocalDateTime.now()

    /**
     * 创建人
     */
    @MybatisPlusMetaProperty(MetaColumn.USER_ID)
    @TableField(
        fill = FieldFill.INSERT,
        updateStrategy = FieldStrategy.NEVER
    )
    var creatorId: String = ""

    /**
     * 创建人名称
     */
    @MybatisPlusMetaProperty(MetaColumn.USER_NAME, relativeProp = "creatorId")
    @TableField(
        fill = FieldFill.INSERT,
        updateStrategy = FieldStrategy.NEVER
    )
    var creatorName: String = ""

    /**
     * 更新时间
     */
    @TableField(
        insertStrategy = FieldStrategy.NEVER,
        updateStrategy = FieldStrategy.NEVER,
        update = "CURRENT_TIMESTAMP"
    )
    var updateTime: LocalDateTime = LocalDateTime.now()

    /**
     * 更新人
     */
    @TableField(
        fill = FieldFill.UPDATE,
        insertStrategy = FieldStrategy.NEVER,
        updateStrategy = FieldStrategy.NEVER
    )
    var updatorId: String = ""

    /**
     * 更新人名称
     */
    @TableField(
        fill = FieldFill.UPDATE,
        insertStrategy = FieldStrategy.NEVER,
        updateStrategy = FieldStrategy.NEVER
    )
    var updatorName: String = ""

    /**
     * 删除时间
     */
    @TableLogic
    var deleteTime: LocalDateTime? = null
}
```

## 安全规范

### 认证授权
- 使用 JWT 进行身份认证
- 实现基于角色的权限控制
- 支持细粒度的权限验证
- 提供权限拦截器

### 数据安全
- 密码加密存储
- 敏感数据脱敏
- 输入参数验证
- SQL注入防护

### 接口安全
- 使用 HTTPS 传输
- 实现接口限流
- 防止XSS攻击
- 记录安全审计日志

## 缓存策略

### Redis缓存
- 缓存热点数据
- 实现缓存更新策略
- 支持缓存穿透防护
- 配置缓存过期时间

### 本地缓存
- 使用 Caffeine 本地缓存
- 缓存配置信息
- 减少数据库访问
- 提升响应性能

## 异常处理

### 异常分类
- **业务异常**: 业务逻辑错误
- **系统异常**: 系统内部错误
- **参数异常**: 参数验证错误
- **权限异常**: 权限不足错误

### 全局异常处理
```kotlin
@RestControllerAdvice
class GlobalExceptionHandler {
    @ExceptionHandler(BusinessException::class)
    fun handleBusinessException(e: BusinessException): ApiResult<Nothing> {
        return ApiResult.error(e.code, e.message)
    }

    @ExceptionHandler(MethodArgumentNotValidException::class)
    fun handleValidationException(e: MethodArgumentNotValidException): ApiResult<Nothing> {
        val message = e.bindingResult.fieldErrors.joinToString { it.defaultMessage ?: "" }
        return ApiResult.error(400, message)
    }
}
```

## 测试规范

### 单元测试
- 每个业务方法都要有单元测试
- 使用 JUnit 5 + Mockito
- 测试覆盖率 > 80%
- 测试用例命名清晰

### 集成测试
- 测试完整的业务流程
- 测试数据库操作
- 测试缓存功能
- 使用测试容器

### API测试
- 测试所有接口
- 验证请求参数
- 检查响应格式
- 测试异常场景

## 性能优化

### 数据库优化
- 合理使用索引
- 避免N+1查询问题
- 使用分页查询
- 优化SQL语句

### 缓存优化
- 缓存热点数据
- 使用缓存预热
- 实现缓存更新策略
- 监控缓存命中率

### 应用优化
- 使用连接池
- 合理配置线程池
- 异步处理耗时操作
- 优化序列化性能

## 部署规范

### 容器化部署
- 使用 Docker 容器化
- 提供 Dockerfile
- 支持多阶段构建
- 优化镜像大小

### 环境配置
- 开发环境: 本地开发
- 测试环境: 集成测试
- 生产环境: 生产部署

### 监控告警
- 集成 Spring Boot Actuator
- 配置健康检查
- 设置性能监控
- 配置告警规则

## 开发流程

### 功能开发流程
1. 设计数据库表结构
2. 创建实体类和DTO
3. 实现数据访问层
4. 实现业务逻辑层
5. 实现控制器层
6. 编写单元测试
7. 集成测试验证
8. 性能测试优化

### 代码审查
- 代码规范检查
- 业务逻辑审查
- 安全漏洞检查
- 性能问题检查

### 版本管理
- 使用语义化版本号
- 保持向后兼容性
- 提供升级指南
- 支持回滚操作
